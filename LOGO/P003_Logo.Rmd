---
title: "P003: Logo Repeat"
author: "Hubert Baechli"
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Logo

**Goal:** Programming a simple language with R

Logo goes back much earlier than the Apple II, it was developed in 1967 by Cynthia Solomon, Wally Feurzig, and Seymour Papert. That's five years before C and 24 years before Python! The three worked at Bolt, Beranek, and Newman (BBN), famous for all kinds of other computing history. BBN built the first Interface Message Processors (early routers) in 1968 for the ARPANET, which would evolve into the modern internet. [...learn more](https://learn.adafruit.com/program-logo-on-an-apple-ii/what-is-logo)

## Basic Commands

Implementing the basic commands [see "Hello Turtle"](https://learn.adafruit.com/program-logo-on-an-apple-ii/hello-turtle)

### NEW

Initializing the game

```{r}
NEW <- function (size, data = LOGO) {
  field_name <- deparse(substitute(data))
  pos <- 1
  heading <- 0
  turtle <- TRUE
  turtle_color <- "red"
  path_color <- "blue"
  path <- data.frame(x = 0, y = 0, rad = 0, color = "transparent")
  field <- NULL
  data <- list(field = field,
               size = abs(size),
               field_name = toupper(field_name),
               pos = pos,
               heading = heading,
               turtle_color = turtle_color,
               turtle = turtle,
               path_color = path_color,
               path = path)
  data <- CLEARSCREEN(data)
  data
}
```

### CLEARSCREEN (CS)

Clear the screen and initializing the field

```{r}
CLEARSCREEN <- function (data = LOGO) {
  plot.new()
  plot.window(xlim = c(-data$size, data$size),
              ylim = c(-data$size, data$size))
  box()
  grid()
  axis(1)
  axis(2)
  data$field <- recordPlot()
  plot_turtle(data, show = data$turtle)
  data
}
```

```{r}
CS <- function (data = LOGO) {
  CLEARSCREEN(data)
}
```

### HIDETURTLE (HT)

Don't show the turtle cursor.

```{r}
HIDETURTLE <- function (data) {
  data$turtle <- FALSE
  replayPlot(data$field)
  data
}
```

```{r}
HT <- function (data) {
  HIDETURTLE(data)
}
```

### SHOWTURTLE (ST)

Show the turtle cursor.

```{r}
plot_turtle <- function (data, show) {
  if (show) {
    points(x = data$path$x[data$pos],
           y = data$path$y[data$pos],
           col=data$turtle_color,
           pch = 16,
           cex = 1.5)
    arrow_length <- 0.6
    angle <- data$path$rad[data$pos]
    arrows(data$path$x[data$pos],
           data$path$y[data$pos],
           data$path$x[data$pos] + cos(angle) * arrow_length,
           data$path$y[data$pos] + sin(angle) * arrow_length,
           col = data$turtle_color,
           code = 2,
           length = 0.1,
           angle = 20,
           lwd = 2)
  }
}
```

```{r}
SHOWTURTLE <- function (data) {
  data$turtle <- TRUE
  data$field <- recordPlot()
  replayPlot(data$field)
  plot_turtle(data, show = data$turtle)
  data
}
```

```{r}
ST <- function (data) {
  SHOWTURTLE(data)
}
```

### FORWARD (FD)

Move forward *steps*.

```{r}
record_path <- function (data, x, y, show = TRUE) {
  if (show) { 
    color <- data$path_color 
    } else {
    color <- "transparent"
    }
  rad <- data$path$rad[data$pos]
  data$path <- rbind(data$path, data.frame(x, y, rad, color))
  data$pos <- data$pos + 1
  data
}
```

```{r}
FORWARD <- function (steps, data) {
  replayPlot(data$field)
  angle <- data$path$rad[data$pos] 
  x0 <- data$path$x[data$pos]
  y0 <- data$path$y[data$pos]
  x1 <- x0 + cos(angle) * steps
  y1 <- y0 + sin(angle) * steps
  segments(x0, y0, x1, y1,
           col = data$path_color,
           lwd = 2)
  data$field <- recordPlot()
  data <- record_path(data, x1, y1)
  plot_turtle(data, show = data$turtle)
  data
}
```

```{r}
FD <- function (steps, data) {
  FORWARD(steps, data)
}
```

### BACK (BK)

Move back *steps*.

```{r}
BACK <- function (steps, data) {
  FORWARD(-steps, data)
}
```

```{r}
BK <- function (steps, data) {
  BACK(steps, data)
}
```

### LEFT (LT)

Turn left this many degrees. Negative degrees work too, they'll turn it right.

```{r}
LEFT <- function (degs, data) {
  replayPlot(data$field)
  data$heading <- data$heading + degs
  data$path$rad[data$pos] <- data$heading * pi / 180
  plot_turtle(data, show = data$turtle)
  data
}
```

```{r}
LT <- function (degs, data) {
  LEFT(degs, data)
}
```

### RIGHT (RT)

Turn right this many degrees.

```{r}
RIGHT <- function (degs, data) {
  LEFT(-degs, data)
}
```

```{r}
RT <- function (degs, data) {
  RIGHT(degs, data)
}
```

### SETHEADING (SH)

Turn to an absolute heading of *degrees*.

```{r}
SETHEADING <- function (deg, data) {
  replayPlot(data$field)
  data$heading <- deg
  data$path$rad[data$pos] <- data$heading * pi / 180
  plot_turtle(data, show = data$turtle)
  data
}
```

```{r}
SH <- function (deg, data) {
  SETHEADING(deg, data)
}
```

### SETPOS (SP)

Set the position to *x, y* coordinates. These are Cartesian, so 0,0 is the middle of the screen.

```{r}
SETPOS <- function (x1, y1, data) {
  replayPlot(data$field)
  x0 <- data$path$x[data$pos]
  y0 <- data$path$y[data$pos]
  segments(x0, y0, x1, y1,
           col = "transparent",
           lwd = 2)
  data$field <- recordPlot()
  data <- record_path(data, x1, y1, show = FALSE)
  plot_turtle(data, show = data$turtle)
  data
}
```

```{r}
SP <- function (x1, y1, data) {
  SETPOS(x1, y1, data)
}
```

### HOME

Move back to the home position.

```{r}
HOME <- function (data) {
  SETPOS(x1 = 0, y1 = 0, data)
}
```

### SETX (SX)

Set the horizontal position to *x*.

```{r}
SETX <- function (x1, data) {
  SETPOS(x1, y1 = data$path$y[data$pos], data)
}
```

```{r}
SX <- function (x1, data) {
  SETX(x1, data)
}
```

### SETY (SY)

Set the vertical position to *y*.

```{r}
SETY <- function (y1, data) {
  SETPOS(x1 = data$path$x[data$pos], y1, data)
}
```

```{r}
SY <- function (y1, data) {
  SETY(y1, data)
}
```

### COPYPATH (CP)

Copy or store a path.

```{r}
COPYPATH <- function (data) {
  data$path
}
```

```{r}
CP <- function (data) {
  COPYPATH(data)
}
```

### PASTEPATH (PP)

```{r}
PASTEPATH <- function (data, path, add = FALSE) {
  if (add) {
      data$path <- rbind(data$path, path)
    } else {
      data$path <- path
    }
  data$pos <- nrow(data$path)
  data$heading <- (data$path$rad[data$pos] / pi * 180) %% 360
  replayPlot(data$field)
  for (i in 2:nrow(data$path)) {
    segments(x0 = data$path$x[i-1],
             y0 = data$path$y[i-1],
             x1 = data$path$x[i],
             y1 = data$path$y[i],
             col = data$path$col[i],
             lwd = 2)
  }
  data$field <- recordPlot()
  plot_turtle(data, show = data$turtle)
  data
}
```

```{r}
PP <- function (data, path, add = FALSE) {
  PASTEPATH(data, path, add)
}
```

## Prompt option

### Single Function Prompt

#### Clean strings

```{r}
clean_prompt <- function (Prompt) {
  Prompt <- toupper(Prompt)
  Prompt <- gsub("\\[", " [ ", Prompt)
  Prompt <- gsub("\\]", " ] ", Prompt)
  Prompt <- gsub("\\(\\s+", "(", Prompt)
  Prompt <- gsub("\\s+\\)", ")", Prompt)
  Prompt <- gsub("-\\s+", "-", Prompt)  
  Prompt <- gsub("\\s+", " ", Prompt)
  Prompt <- trimws(Prompt)
  Prompt
}
```

```{r}
Test_Prompt = " ( NEW]   -7    "
clean_prompt(Test_Prompt)
```

#### Create Call from a String

```{r}
run_prompt <- function (Prompt, data ) {
  vec_Prompt <- strsplit(Prompt, " ")[[1]]
  
  func <- grep("^[A-Z]+$", vec_Prompt, value = FALSE)
  value <- grep("^[A-Z]+$", vec_Prompt, value = TRUE)
  value <- lapply(value, as.name)
  vec_Prompt[func] <- value
  
  num <- grep("^-?[0-9]+$", vec_Prompt, value = FALSE)
  value <- grep("^-?[0-9]+$", vec_Prompt, value = TRUE)
  value <- lapply(value, as.numeric)
  vec_Prompt[num] <- value
  
  vec_Prompt <- c(vec_Prompt, as.name("data"))
  
  run_Prompt <- as.call(vec_Prompt)
  eval(run_Prompt)
}
```

### Multiple Function Prompt

#### Analyzing and spliting Code

```{r}
breakup_String <- function(String) {
  prompts <- clean_prompt(String)
  prompts <- strsplit(prompts, " ")[[1]]
  df <- data.frame(code = prompts)
  n_func <- 0
  df$n_Func <- rep(0, nrow(df))
  df$ID_Repeat <- rep(0, nrow(df))
  df$n_Repeat <- rep(1, nrow(df))
  
  ID <- 1
  brakets <- data.frame(ID = ID,
                        Status = TRUE,
                        n = 1)
  
  i <- 1
  imax <- nrow(df) + 1
  
  while ( i < imax ) {
    if ( length(grep("^[A-Z]+$", df$code[i])) > 0 ) {
      if (df$code[i] == "REPEAT") {
        n_func <- n_func + 1
        ID <- ID + 1
        i = i + 2
        brakets <- rbind(brakets,
                         data.frame(ID = ID, 
                                    Status = TRUE, 
                                    n = as.numeric(df$code[i - 1])))
        level <- brakets$ID[max(which(brakets$Status == TRUE))]
        df$ID_Repeat[i] <- ID
        df$n_Repeat[i] <- df$code[i - 1]
      } else { n_func <- n_func + 1 }
    }
    
    if (df$code[i] == "]") {
      level <- brakets$ID[max(which(brakets$Status == TRUE))]
      brakets$Status[brakets$ID == level] <- FALSE
      } else {
        df$n_Func[i] <- n_func
        level <- brakets$ID[max(which(brakets$Status == TRUE))]
        df$ID_Repeat[i] <- brakets$ID[brakets$ID == level]
        df$n_Repeat[i] <- brakets$n[brakets$ID == level]
        }
    i <- i + 1
  }
  
  df_func <- data.frame(ID = 1, Prompt = "", n = 1)
  func <- rev(unique(df$n_Func[df$n_Func != 0]))
  for (i in func) {
    Prompt <- paste(df$code[df$n_Func == i], collapse = " ") 
    ID <- max(df$ID_Repeat[df$n_Func == i])
    n <- brakets$n[brakets$ID == ID]
    df_func <- rbind(data.frame(ID = ID, Prompt = Prompt, n = n), 
                     df_func)
    }
  df_func <- rbind(data.frame(ID = 1, Prompt = "", n = 1),
                   df_func)
  return(df_func)
}
```

```{r}
CodeLine <- "fd 2 REPEAT 2 [REPEAT 3 [FD - 1 RT 2] RT 18] "
CodeLine <- " HT FD 3 ST CS HOME"
cl_splited <-breakup_String(CodeLine)
cl_splited
```

#### Expand Repeats

```{r}

expand_Repeats <- function (splited) {
  df <- splited
  IDmax <- max(df$ID)
  while (IDmax > 1){
    rID <- range(which(df$ID == IDmax))
    n <- df$n[rID[1]]
    
    middle <- (rID[1] + 1):rID[2]
    dfm <- df[middle, ]
    for (i in 2:n) {
      dfm <- rbind(dfm,df[middle, ])
      }
    dfm$ID <- df$ID[rID[1]-1]
    dfm$n <- df$n[rID[1]-1]
    
    before <- 1:(rID[1] - 1)
    dfb <- df[before, ]
    
    after <- (rID[2] + 1):nrow(df)
    dfa <- df[after, ]
    
    df <- rbind(dfb,dfm,dfa)
    IDmax <- max(df$ID)
  }
  return(df$Prompt[df$Prompt != ""])
}
```

```{r}
Prompts <- expand_Repeats(cl_splited)
Prompts
```

#### Create Calls from a Vector of Strings

```{r}
run_prompts <- function (Prompt, data = LOGO) {
  df <- breakup_String(Prompt)
  Prompts <- expand_Repeats(df)
    for (i in 1:length(Prompts)){
      data <- run_prompt(Prompts[i], data)
      }
  data
}
```


# Run Game

## Example from the homepage

```{r fig.width=8, fig.height=8}

LOGO <- NEW(3)
LOGO <- run_prompts(" REPEAT 10 [REPEAT 36 [FD 1 RT 40] RT 36]")

```
